/***************************************************************/
/* Copyright 2025 Xenon Emulator Project. All rights reserved. */
/***************************************************************/

#pragma once

#include <memory>
#include <mutex>

#include "Base/Types.h"

#include "XenonSOC.h"

#include "Core/PCI/Devices/RAM/RAM.h"
#include "Core/RootBus/RootBus.h"
#include "Core/XCPU/eFuse.h"
#include "Core/XCPU/Context/Reservations/XenonReservations.h"
#include "Core/XCPU/IIC/IIC.h"

namespace Xe::XCPU {

  // Main Xenon CPU 'context'
  // Contains all of the internal CPU components and SOC logic aside from the Power Processing Elements and is shared
  // for all three PPE's an their respecting Power Processing Units (PPU's) threads.
  class XenonContext {
  public:
    XenonContext(RootBus *rootBusPtr, RAM *ramPtr) :
      rootBus(rootBusPtr), ram(ramPtr)
    {
      SROM = std::make_unique<STRIP_UNIQUE_ARR(SROM)>(XE_SECROM_BLOCK_SIZE);
      SRAM = std::make_unique<STRIP_UNIQUE_ARR(SROM)>(XE_SECRAM_BLOCK_SIZE);
      socSecOTPBlock = std::make_unique<STRIP_UNIQUE(socSecOTPBlock)>();
      socSecEngBlock = std::make_unique<STRIP_UNIQUE(socSecEngBlock)>();
      socSecRNGBlock = std::make_unique<STRIP_UNIQUE(socSecRNGBlock)>();
      socCBIBlock = std::make_unique<STRIP_UNIQUE(socCBIBlock)>();
      socINTBlock = std::make_unique<STRIP_UNIQUE(socINTBlock)>();
      socPMWBlock = std::make_unique<STRIP_UNIQUE(socPMWBlock)>();
      socPRVBlock = std::make_unique<STRIP_UNIQUE(socPRVBlock)>();
    }
    ~XenonContext() {
      SROM.reset();
      SRAM.reset();
      socSecOTPBlock.reset();
      socSecEngBlock.reset();
      socSecRNGBlock.reset();
      socCBIBlock.reset();
      socINTBlock.reset();
      socPMWBlock.reset();
      socPRVBlock.reset();
    }

    RootBus *GetRootBus() { return rootBus; }
    RAM *GetRAM() { return ram; }
    bool HandleSOCRead(u64 readAddr, u8 *data, size_t byteCount);
    bool HandleSOCWrite(u64 writeAddr, const u8 *data, size_t byteCount);

    // Xenon SecureROM
    // Contains the CPU's main startup code known as 1BL.
    std::unique_ptr<u8[]> SROM{};
    // Xenon SecureRAM
    // The SRAM is used during the early boot process for the CPU to decrypt the second stage booloader on the system.
    // It is also used in conjuction with the Xenon's 'Security Engine' for cryptographic purposes (Holds the keyset
    // generated by it).
    std::unique_ptr<u8[]> SRAM{};
    // Xenon eFuses
    // Each Xenon CPU has a built-in One-Time-Programmable storage (768 bits) that contains per-cpu data and security
    // flags, these include:
    // * Console type (Devkit/Retail)
    // * SB/CB (Second stage bootloaders (Devkit/Retail respectively)) 'lockdown value'.
    // * CPU 'Key'. A 16 byte string that it's used during the boot process for cryptographic and security purposes.
    // * SD/CD (Kernel) 'lockdown value'.
    eFuses fuseSet = {};
    // Xenon Integrated Interrupt Controller
    // This is a built-in interrupt controller that holds and coordinates interrupts betweeen the PPU's and the
    // external system peripherals.
    IIC::XenonIIC xenonIIC = {};
    // Used for conditional load/store instructions regarding PowerPC atomic operations.
    XenonReservations xenonRes = {};
    // Time Base switch, possibly RTC register, the TB counter only runs if this
    // value is set.
    bool timeBaseActive = false;
    //
    // SOC Blocks
    //
    // Secure OTP Block
    std::unique_ptr<SOC::SOCSECOTP_ARRAY> socSecOTPBlock{};
    // Security Engine Block
    std::unique_ptr<SOC::SOCSECENG_BLOCK> socSecEngBlock{};
    // Secure RNG Block
    std::unique_ptr<SOC::SOCSECRNG_BLOCK> socSecRNGBlock{};
    // CBI Block
    std::unique_ptr<SOC::SOCCBI_BLOCK> socCBIBlock{};
    // INT Block
    std::unique_ptr<SOC::SOCINTS_BLOCK> socINTBlock{};
    // PMW Block
    std::unique_ptr<SOC::SOCPMW_BLOCK> socPMWBlock{};
    // Pervasive Block
    std::unique_ptr<SOC::SOCPRV_BLOCK> socPRVBlock{};
  private:
    // Mutex for thread safety
    std::recursive_mutex mutex{};
    // RootBus pointer
    RootBus *rootBus{};
    // RAM pointer
    RAM *ram{};

    // SOC Blocks R/W.

    // Security Engine Block.
    bool HandleSecEngRead(u64 readAddr, u8 *data, size_t byteCount);
    bool HandleSecEngWrite(u64 writeAddr, const u8 *data, size_t byteCount);

    // Secure OTP Block.
    bool HandleSecOTPRead(u64 readAddr, u8 *data, size_t byteCount);
    bool HandleSecOTPWrite(u64 writeAddr, const u8 *data, size_t byteCount);

    // Secure RNG Block.
    bool HandleSecRNGRead(u64 readAddr, u8 *data, size_t byteCount);
    bool HandleSecRNGWrite(u64 writeAddr, const u8 *data, size_t byteCount);

    // CBI Block.
    bool HandleCBIRead(u64 readAddr, u8 *data, size_t byteCount);
    bool HandleCBIWrite(u64 writeAddr, const u8 *data, size_t byteCount);

    // INT Block.
    bool HandleINTRead(u64 readAddr, u8 *data, size_t byteCount);
    bool HandleINTWrite(u64 writeAddr, const u8 *data, size_t byteCount);

    // PMW Block.
    bool HandlePMWRead(u64 readAddr, u8 *data, size_t byteCount);
    bool HandlePMWWrite(u64 writeAddr, const u8 *data, size_t byteCount);

    // Pervasive logic Block.
    bool HandlePRVRead(u64 readAddr, u8 *data, size_t byteCount);
    bool HandlePRVWrite(u64 writeAddr, const u8 *data, size_t byteCount);
  };
}